# 23.工具调用的基本机制

这一章节讲讲LLM调用工具的基本机制。

## 一、什么是工具调用(Tool / Function Calling)

工具调用不是指大模型直接去操作工具，比如点击网页或打开软件。记住，LLM永远不会执行，它只会表达意图。
工具调用本质上是一种“协议对话”机制。 它是模型与外部系统之间达成的一种协议规范。模型通过输出一种结构化文本（通常是 JSON），明确表达它想要调用的工具名称以及参数，由外部环境（你的代码或系统）执行该工具，并将结果回传给模型。
完整链路如下：

```
用户输入  
→ 模型理解与决策  
→ 模型输出结构化调用请求（JSON / AST）  
→ 外部系统执行工具  
→ 真实结果回传模型  
→ 模型基于真实结果继续推理或输出
```

**示例**
用户说：

> 帮我查一下今天上海的天气，顺便判断适不适合洗车。

系统中有一个工具：

`get_weather(city)`

模型此时不会“编天气”，而是输出类似：

```json
{
  "name": "get_weather",
  "arguments": {
    "city": "Shanghai"
  }
}
```

你的程序执行真实查询，把结果（比如：小雨，湿度 90%）回传给模型。

模型再基于真实数据输出：

> 今天有小雨，不适合洗车。

## 二、Tool Schema 的本质

Tool Schema的本质是能力说明书。
模型怎么知道你提供了哪些工具？它又怎么知道该传什么参数？答案就在 **Tool Schema**。

### Schema 是什么？

Schema 是对工具的**标准化描述**。它告诉模型：

* **名称 (Name)**：工具叫什么？（如 `get_weather`）
* **功能描述 (Description)**：这个工具是干什么的？（如“获取指定城市的实时天气”）
* **参数 (Parameters)**：需要输入什么信息？格式是什么？哪些是必填的？

例如：

```json
{
  "name": "web_search",
  "description": "当用户询问实时新闻或其知识库之外的信息时，使用此工具搜索互联网。",
  "parameters": {
    "type": "object",
    "properties": {
      "query": { "type": "string", "description": "搜索关键词，例如 '2026年冬奥会地点'" }
    },
    "required": ["query"]
  }
}
```

这里最重要的不是 JSON 结构。

而是这句话：

> “当用户询问实时新闻或其知识库之外的信息时…”

这是在**教模型什么时候应该放弃胡说，转而请求外部能力。**

在传统编程里，注释写得好不好，不影响程序执行。
但在工具调用中，描述写得好不好，直接决定模型**会不会用、会不会乱用、会不会用错**。

对模型来说，Schema代表能力边界，Description就是使用说明书，参数是工具的结构映射
比如一个 **坏 Schema**：

```json
{
  "name": "func1",
  "description": "处理数据",
  "parameters": {...}
}
```

这个Schema模型完全不知道, 在什么场景下会处理什么数据。

一个**好 Schema**：

```json
{
  "name": "search_orders",
  "description": "当用户需要查询真实订单状态、金额、时间、客户信息时，使用此工具从订单系统获取权威数据。",
  "parameters": {...}
}
```

这样的Schema就知道这个工具提供的是订单能力，并且返回的是订单的真实权威数据。

## 三. 模型在工具调用中做了什么？

有些教程会说：“模型决定是否调用函数。”，但这并没有说清楚底层逻辑。

在整个调用链路中，模型并不是直接运行了代码，它其实完成了三个关键的过程：**意图识别、参数提取、格式封装**。

### 第一步：识别意图

模型阅读用户的提问，并对比所有可用工具的 Schema。

* **用户问**：“上海现在几度？”
* **模型想**：“我的训练数据是旧的，但我有一个 `get_weather` 工具，它的描述正符合这个需求。”

### 第二步：能力匹配（该用哪个工具？）

当系统提供多个工具时，比如查订单、查用户、搜索网页、运行代码等。

模型在做的是问题语义 → 能力语义 的匹配。

例如：

> “帮我算一下上周张三的订单总额。”

模型会隐式拆解为：

* 需要订单数据 → search_orders
* 需要数学计算 → calculator / python

### 第三步：提取参数

模型从自然语言中抽取实体与约束：

* 谁（张三）
* 什么（订单）
* 时间（上周）
* 动作（求和）

并构造成：

```json
{
  "name": "search_orders",
  "arguments": {
    "customer_name": "张三",
    "date_range": "last_week"
  }
}
```

### 第四步：结果处理

当工具返回结果后，模型不会“结束”，而是继续判断：

* 目标是否完成？
* 是否需要二次调用？
* 是否要解释 / 汇总 / 对比 / 风控判断？

例如：

> 查订单 → 拿到列表 → 调计算工具 → 再输出结论

以上就是工具调用的基本机制。
在实际落地中，会出现Schema定义杂乱、返回数据结果不一致、工具太多怎么办等痛点，这些会在后续章节中进行讨论。