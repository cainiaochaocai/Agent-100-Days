# 16.Prompt 的通用技巧

在Day 15 我们已经明确了一件事：Prompt 不是语言艺术，而是**概率分布控制 + 结构工程**。

因此，从今天开始，我们避免长段小作文式、把所有要求混在 Prompt的写法，学习像写文档一样写 Prompt、像设计接口一样设计 Prompt  、像写轻量程序一样组织 Prompt。

## 一、编写 Prompt 的通用技巧

大多数 Prompt 写不好，并不是因为不懂模型，而是因为在用“写给人看的方式”写 Prompt。

但模型不是人，它不擅长“领会精神”，它只擅长拟合结构、复制模式、延续格式。

所以提示词工程的第一原则是：用结构代替语义，用协议代替描述。

比如下面的提示词：

```text
你是一个非常专业而且经验丰富的分析师，现在我给你一段项目资料，希望你能够帮我认真分析一下这个项目的优缺点、存在的问题以及未来可能的发展方向，最好能从多个角度展开，并给我一些有价值的建议。
```

这段提示词没模块化、没有边界、没稳定输出结构，也不可复用。

所以好的提示词用框架而不是灵感写 Prompt。工程写 Prompt 的本质，是**模块设计**。

这里介绍两种典型的框架CO-STAR和RTF框架。

### 1.CO-STAR 框架（通用任务向）

CO-STAR 偏向**通用任务理解与表达控制**，非常适合：

* 知识工作类任务

* 分析 / 写作 / 总结 / 评估

* 人机协作场景

* 教学与探索型 Prompt

**CO-STAR 各模块含义**

CO-STAR 是 6 个 Prompt 组件的缩写：

| 字母            | 含义           |
| ------------- | ------------ |
| C – Context   | 背景 / 状态 / 前提 |
| O – Objective | 总目标          |
| S – Style     | 风格 / 角色      |
| T – Task      | 具体任务         |
| A – Audience  | 目标受众         |
| R – Response  | 输出格式         |

CO-STAR 的核心思想是把“人类在沟通中默认隐含的信息”，显式写出来。

比如我们平时和人说话，往往默认包含：

* 在什么场景下
* 目的是什么
* 你是谁
* 给谁看
* 要产出什么形式

而模型没有这些隐含背景，你必须结构化提供。

**示例**

```text
# Context
你正在参与一场创业项目评审会议。

# Objective
评估项目是否值得进入下一轮尽调。

# Style
你是一名极度保守的风控型投资人。

# Task
请分析该项目的核心价值与主要风险。

# Audience
投资决策委员会。

# Response
请按以下结构输出：
1. 一句话结论  
2. 三个支持理由  
3. 三个关键风险  
4. 是否进入下一轮（Yes/No + 原因）

# Input
{{project_info}}
```

### 2.RTF 框架（工程 / Agent 向 Prompt）

RTF 更偏向**系统工程与 Agent 架构**，适合：

* 自动化系统
* Agent 模块
* Pipeline 节点
* 长期运行 Prompt
* 可编排 Prompt

**RTF 各模块含义**

RTF 只有三个核心模块：

| 字母         | 含义   |
| ---------- | ---- |
| R – Role   | 长期角色 |
| T – Task   | 当前任务 |
| F – Format | 输出格式 |

RTF 的目标不是“表达完整”，而是像写函数一样写 Prompt。

它关心的核心是：

* 模块边界
* 稳定角色
* 明确输入
* 稳定输出接口

**示例**

```text
# Role
你是一个投研系统中的风险分析模块。

# Task
识别项目中的系统性风险。

# Input
{{project_info}}

# Format
{
  "core_risks": [],
  "severity": "High/Medium/Low",
  "reason": "",
  "verification_points": []
}
```

### 3.分隔符

模型对结构极其敏感，所以合理的分隔符，相当于给Token 分布做分区。

#### 常用三类分隔方式

**a.Markdown 结构分隔**

```text
# Role
# Task
# Input
# Constraints
# Output Format
```

适合：

- 人机共读

- 教程型 Prompt

- 快速工程设计

**a.显式分隔符**

```text
###
--- 
=====
```

适合：

- 长上下文

- 多段拼接

- 工具自动注入

**c.XML / Tag 结构**

```xml
<role>风险分析专家</role>

<context>
你正在评估一个早期创业项目
</context>

<input>
{{project_info}}
</input>

<output_format>
JSON
</output_format>
```

适合：

- 程序拼 Prompt

- Agent 框架

- 上下文注入系统

### 4.变量占位符

工程 Prompt 的核心能力之一是：不为一次任务写 Prompt，而是为**一类任务写 Prompt**。

这就必须使用变量占位。

**示例：不可复用 Prompt**

```text
请分析小米汽车项目的市场前景……
```

**示例：函数型 Prompt**

```text
请分析以下项目的市场前景：
{{project_description}}
```

或者：

```text
<Input>
{{input}}
</Input>
```

这样 Prompt 才能：

- 被代码调用

- 被 Agent 填充

- 被批量运行

- 被工作流编排

### 5.轻量程序

当具备前面的能力后，Prompt 会自然演化成一种形态：

```text
状态声明
+ 输入接口
+ 处理协议
+ 输出规范
```

它和传统程序的区别不在于“有没有逻辑”，而在于程序控制执行，Prompt 控制分布。

但工程目标是一样的，都是为了降低不确定性、提高稳定性、方便组合。

### 6.用结构代替语义，用协议代替描述

这是提示词最重要的一条原则。

比如通常的语义型写法:

> 请你尽量全面、深入、专业、严谨地分析，并给出高质量建议。

这是在向模型“许愿”，而协议型写法明确模型的输出，提供稳定性。

```text
输出必须包含：
- 明确结论
- 不少于3个可验证依据
- 风险与不确定性
- 下一步行动建议
```

## 二、编写 Prompt 需要注意什么

在实际编写中，请务必避开以下坑点：

1. **避免否定指令**：模型对“不要”不够敏感。
* 错误：“不要使用专业术语。”
* 正确：“请使用通俗易懂、口语化的语言，解释得像在对 10 岁孩子说话。”
2. **具体的约束胜过模糊的赞美**：
* 错误：“写一个非常好的故事。”
* 正确：“写一个包含起承转合结构、具有意外结局、字数在 500 字左右的职场寓言。”
3. **少即是多**：
* Prompt 不是越长越好。多余的废话会摊薄核心指令的概率权重。